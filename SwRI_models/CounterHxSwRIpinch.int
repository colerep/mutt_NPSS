/*******************************************************************************
Copyright 2003. The U.S. Government, as Represented by the Administrator of
the National Aeronautics and Space Administration (NASA). All rights reserved.
Includes content licensed from the U.S. Government, National Aeronautics and
Space Administration under United States Copyright Registration Numbers
V3503D364 and V3482D344.
Copyright 2008-2013 NPSS Consortium, www.NPSSConsortium.org/AllRightsReserved
*******************************************************************************/

/*******************************************************************************
NPSS software and related documentation is export controlled with an Export
Control Classification Number(ECCN) of 9D991, controlled for Anti-Terrorism
reasons, under U.S. Export Administration Regulations 15 CFR 730-774. It may
not be transferred to a country checked under anti-terrorism on the Commerce
Country Chart structure or to foreign nationals of those countries in the U.S.
or abroad without first obtaining a license from the Bureau of Industry and
Security, United States Department of Commerce. Violations are punishable by
fine, imprisonment, or both.
*******************************************************************************/
//
// For further information contact support@npssconsortium.org
//

#ifndef __CounterHxSwRIpinch__
#define __CounterHxSwRIpinch__

#include <InterpIncludes.ncp>

class CounterHxSwRIpinch extends Element {

  //------------------------------------------------------------
  // ******* DOCUMENTATION *******
  //------------------------------------------------------------

  title = "";

  description = isA() + " models thermal energy transfer between two parallel streams using either
  an effectiveness or heat flow.  Pressure losses may be applied to each stream.";



  usageNotes = isA() +
  "

  - Energy exchanged between the two streams is defined by either effectiveness
  (effect) or total heat flow (Q) as determined by switchQcalc.  These values
  may be directly input or determined by a subelement plugged into the S_Q
  socket.

  - Stream pressure drops may be input through sockets, S_dPqP1 and S_dPqP2 or if
  sockets are empty directly through dPqP1 and dPqP2.

  - Heat exchanger may be turned off by setting either effect or Q to zero.

  - Steady-state operating conditions only.  Transient thermal transfer and
  storage in structure is not modeled.

  - The calculations are based on 'Compact Heat Exchangers. Third Edition' by
  W. M. Kays and A. L. London, The National Press, 1984.
  ";

  //------------------------------------------------------------
  // ******* SETUP VARIABLES********
  //------------------------------------------------------------

  // Real variables
  real cap1 {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC_R;
    description = "Capacity of flow stream 1 (W*Cp)";
  }
  real cap2 {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC_R;
    description = "Capacity of flow stream 2 (W*Cp)";
  }
  real capMin {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC_R;
    description = "Minimum of the two streams capacities";
  }
  real dPqP_dmd {
    value = 0;  IOstatus = INPUT;  units = NONE;
    description = "Normalized pressure loss (used to temporarily store values returned from the pressure loss sockets)";
  }
  real dPqP1 {
    value = 0;  IOstatus = INPUT;  units = NONE;
    description = "Pressure loss in stream 1";
  }
  real dPqP2{
    value = 0;  IOstatus = INPUT;  units = NONE;
    description = "Pressure loss in stream2";
  }
  real effect_Cp{
    value = 0;  IOstatus = OUTPUT;  units = NONE;
    description = "Heat transfer effectiveness based on cp*dT";
  }
  real effect_des{
    value = 0.95;  IOstatus = INPUT;  units = NONE;
    description = "Design Heat transfer effectiveness";
  }

  real Q {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC;
    description = "Heat flow from one side to another (positive when energy flows from stream 1 to stream 2";
  }
  real Q_des {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC;
    description = "Input value of Q";
  }
  real Q_dmd {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC;
    description = "Demand vale of Q from customer socket";
  }

  // Enthalpy based effectiveness
  real effect_h{
    value = 0;  IOstatus = OUTPUT;  units = NONE;
    description = "Heat transfer effectiveness based on dh";
  }
  real Qmax1 {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC;
    description = "";
  }
  real Qmax2 {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC;
    description = "";
  }
  real Qmin_h {
    value = 0;  IOstatus = OUTPUT;  units = BTU_PER_SEC;
    description = "";
  }

  

  // Approach temperatures
  real approach_cold{
    value = 0;  IOstatus = OUTPUT;  units = "dR";
    description = "Approach temperature from Hot Outlet to Cold Inlet";
  }

  real approach_hot{
    value = 0;  IOstatus = OUTPUT;  units = "dR";
    description = "Approach temperature from Hot Inlet to Cold Outlet";
  }

  real approach_min{
    value = 0;  IOstatus = OUTPUT;  units = "dR";
    description = "Minimum approach temperature";
  }

  real approach_des{
    value = 0;  IOstatus = INPUT;  units = "dR";
    description = "Design approach temperature";
  }

  real minDt{
    value = 1.0;  IOstatus = INPUT;  units = "dR";
    description = "Minimum approach temperature";
  }


  // Calculaiton variables
  string Fl_Ihot, Fl_Ohot, Fl_Icold, Fl_Ocold, capHot, capCold, hotSide, coldSide;
  real hotSign = 1.0;

  // Option variables
  Option switchDes {
    allowedValues = { DESIGN, OFFDESIGN }
    description = "Design/Offdesign switch";
    rewritableValues = FALSE;  // Enables converter optimization.
  }

  Option switchQ {
    allowedValues = { "EFFECT", "Q_des", "APPROACH", "Q_CALCULATE", "Q_CUSTOM", "OFF" }
    description = "Determines if the heat transfer rate is input or calculated from an effectiveness";
    rewritableValues = FALSE;
  }

  Option switchEffectCalc {
    allowedValues = { "h", "Cp" }
    description = "Determines which effectiveness definition to use, Cp or Enthalpy change";
    rewritableValues = FALSE;
  }

  Option switchApproachCalc {
    allowedValues = { "cold", "hot" }
    description = "Determines if approach is calculated at hot stream inlet or outlet ";
    rewritableValues = FALSE;
  }


  Option switchQcalc{
    //allowedValues = { "INPUT", "OFF", "CALCULATE", "CUSTOM", "APPROACH" }
    allowedValues = { "NOT_USED" }
    description = "Determines if the heat transfer rate is input or calculated from an effectiveness";
    rewritableValues = FALSE;
  }


  //------------------------------------------------------------
  // ****** SETUP PORTS, FLOW STATIONS, SOCKETS, TABLES ********
  //------------------------------------------------------------

  // FLUID PORTS

  FluidInputPort Fl_I1 {
    description = "Fluid input port 1" ;
  }
  FluidInputPort Fl_I2 {
    description = "Fluid input port 2" ;
  }
  FluidOutputPort Fl_O1 {
    description = "Fluid output port 1" ;
  }
  FluidOutputPort Fl_O2 {
    description = "Fluid output port 2" ;
  }

  // FUEL PORTS

  // BLEED PORTS

  // THERMAL PORTS

  // MECHANICAL PORTS

  // FLOW STATIONS
  FlowStation Fl_dP {
    description = "Temporary FlowStation used to pass data to the pressure loss Subelements.  Used because the dPnorm subelements expect to reference the incoming conditions in Fl_I.";
  }


  // SOCKETS

  Socket S_dPqP1 {
    description = "Stream 1 pressure loss calculation";
    allowedValues = { "dPqP_dmd" }
    socketType = ADIAB_DPNORM;
  }

  Socket S_dPqP2 {
    description = "Stream 2 pressure loss calculation";
    allowedValues = { "dPqP_dmd" }
    socketType = ADIAB_DPNORM ;
  }

  Socket S_Q {
    description = "Heat flow or effectiveness from stream 1 to stream 2";
    allowedValues = { "Q", "effect", "switchQcalc" }
    socketType = HX_QE;
  }

  Socket S_customQ {
    description = "Customer socket for Q value";
    allowedValues = { "Q_dmd", "effect", "switchQcalc" }
  }

  //------------------------------------------------------------
  // ******* SOLVER SETUP *******
  //------------------------------------------------------------

  SecantSolver iterQscaler {
    description = "solver for";
    maxDx = 0.3;
    tolerance = 1.E-4;  // tolPs
    perturbSize = 0.01;
    maxIters = 50;
  }

  //------------------------------------------------------------
  // ****** ADD SOLVER INDEPENDENTS & DEPENDENT ******
  //------------------------------------------------------------

  //------------------------------------------------------------
  // ******* VARIABLE CHANGED METHODOLOGY *******
  //------------------------------------------------------------
  void variableChanged( string name, any oldVal ) {

    // if ( name == "switchQcalc" ) {
    //   if ( switchQcalc == "Q_des" ) {
    //     Q_des.IOstatus = INPUT;
    //     // effect.IOstatus = OUTPUT;
    //   }
    //   else if ( switchQcalc == "EFFECT" ) {
    //     //Q.IOstatus = OUTPUT;
    //     effect_des.IOstatus = INPUT;
    //   }
    // }

  }



  //------------------------------------------------------------------
  // Calculations
  //------------------------------------------------------------------

  void calcEffectCp(real eff) {
    //------------------------------------------------------------------------
    // Determine cold side temp (TO1) from effectiveness equation
    //------------------------------------------------------------------------
    real ToutCold;
    ToutCold = Fl_Icold->Tt + eff *( Fl_Ihot->Tt - Fl_Icold->Tt )*( capMin / capCold->value );


    //------------------------------------------------------------------------
    // Set the cold side conditions based on the temp and pressure loss
    //------------------------------------------------------------------------
    Fl_Ocold->setTotalTP( ToutCold, Fl_Ocold->Pt * ( 1 - ("dPqP"+coldSide)->value ));

    //------------------------------------------------------------------------
    // Set the hot side conditions based on an energy balance and
    // pressure loss
    //------------------------------------------------------------------------
    Fl_Ohot->setTotal_hP( Fl_Ihot->ht +( Fl_Icold->ht - Fl_Ocold->ht )* Fl_Icold->W /
      Fl_Ihot->W, Fl_Ohot->Pt * ( 1 - ("dPqP"+hotSide)->value ));

    return ( Fl_Icold->ht - Fl_Ocold->ht )* Fl_Icold->W;
  }

  // void calcEffectH(real eff) {
  //   // Note: Qmin_h is calculated to account for minimum approach temperature, minDT
  //   // 100% * Qmin_h results in a minimum approach of minDt
  //   return eff*Qmin_h;
  // }

  void setOutletForQ(real q) {
    //------------------------------------------------------------------
    // Set the exit conditions based on prescribed Q
    //------------------------------------------------------------------
    Fl_O1.setTotal_hP(( Fl_I1.ht - q / Fl_I1.W ), Fl_O1.Pt * ( 1 - dPqP1 ));
    Fl_O2.setTotal_hP(( Fl_I2.ht + q / Fl_I2.W ), Fl_O2.Pt * ( 1 - dPqP2 ));
  }

  void calcApproachQ(string FS1, real Tout, real dPqP) {

    FlowStation FsTemp;
    real Q;
    real dT;

    FsTemp.copyFlow(FS1);
    FsTemp.setTotalTP(Tout,FS1->Pt*(1.-dPqP));
    Q = abs(FsTemp.ht - FS1->ht)*FS1->W;
    return Q;

  }

  void calcEffectH() {
    Qmax1 = calcApproachQ("Fl_I1"->getPathName(),Fl_I2.Tt,dPqP1);
    Qmax2 = calcApproachQ("Fl_I2"->getPathName(),Fl_I1.Tt,dPqP2);
    Qmin_h = min(Qmax1, Qmax2);
    effect_h = abs(Q)/Qmin_h;
  }


  // Check for pinch or minimum approach
  real dtCheck_min, dtCheck, pinchLoc;

  real T1[];
  real T2[];
  real P1[];
  real P2[];
  real DT[];
  int nSamp = 10;

  void calcApproach() {
    
    approach_min = dtCheck_min;
    if ( Fl_I1.Tt > Fl_I2.Tt ) {
      approach_hot = (Fl_I1.Tt - Fl_O2.Tt);
      approach_cold = (Fl_O1.Tt - Fl_I2.Tt);
    } else {
      approach_hot = -(Fl_I1.Tt - Fl_O2.Tt);
      approach_cold = -(Fl_O1.Tt - Fl_I2.Tt);
    }
  }

  void pinchPrint() {
    int i;
    real dtCheck_min, dtCheck, pinchLoc;

    real sgn;
    sgn = 1.;
    if ( Fl_I1.Tt > Fl_I2.Tt ) {
      sgn = 1.;
    } else {
      sgn = -1;
    }

    dtCheck = sgn*(Fl_I1.Tt - Fl_O2.Tt);
    dtCheck_min = dtCheck;
    pinchLoc = 0.;

    cout << endl << "# " << parent.getPathName() << " pinchPrint()" << endl;
    
    string tempStr;
    tempStr = Fl_I1.getPathName(); 
    cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " -> ";
    tempStr = Fl_O1.getPathName(); 
    cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;
    
    tempStr = Fl_O2.getPathName(); 
    cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " <- ";
    tempStr = Fl_I2.getPathName(); 
    cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;

    cout << parent.getPathName() << " " << "i" << " " << "FsTemp1.Pt" << " " << "FsTemp1.Tt" << " " << "FsTemp2.Pt" << " " << "FsTemp2.Tt" << " " << "dtCheck" << " " << "dtCheck_min" << " " << "pinchLoc" << endl;
    for (i=0;i<nSamp+1;i++) {
      
      dtCheck = sgn*(T1[i] - T2[i]);
      if (dtCheck < dtCheck_min) {
        dtCheck_min = dtCheck;
        pinchLoc = 1.0*i/nSamp;
      }

      cout << parent.getPathName() << "\t" << toStr(1.0*i/nSamp,2) << "\t" << P1[i] << "\t" << T1[i] << "\t" << P2[i] << "\t" << T2[i] << "\t" << DT[i] << "\t" << dtCheck_min << "\t" << pinchLoc << endl;
    }

  }

  void pinchCheck() {

    FlowStation FsTemp1;
    FlowStation FsTemp2;

    int i;


    real dP1, dP2;
    real dT1, dT2;
    real dh1, dh2;
    real dQ1, dQ2;


    dP1 = Fl_I1.Pt - Fl_O1.Pt;
    dP2 = Fl_O2.Pt - Fl_I2.Pt;

    dh1 = Fl_I1.ht - Fl_O1.ht;
    dh2 = Fl_O2.ht - Fl_I2.ht;

    // cout << getName() << " " << "Fl_I1"->getPathName() << " " << "Fl_I1"->getParentName() << endl;
    FsTemp1.copyFlow("Fl_I1"->getParentName()+".Fl_I1");
    FsTemp2.copyFlow("Fl_O1"->getParentName()+".Fl_O2");

    T1 = {};
    T2 = {};
    DT = {};
    
    real sgn;
    sgn = 1.;
    if ( Fl_I1.Tt > Fl_I2.Tt ) {
      sgn = 1.;
    } else {
      sgn = -1;
    }


    dtCheck = sgn*(FsTemp1.Tt - FsTemp2.Tt);
    dtCheck_min = dtCheck;
    pinchLoc = 0.;

    // cout << endl << "# " << parent.getPathName() << " pinchCheck()" << endl;
    
    // string tempStr;
    // tempStr = parent.parent.Fl_I1.getPathName(); 
    // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " -> ";
    // tempStr = parent.parent.Fl_O1.getPathName(); 
    // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;
    
    // tempStr = parent.parent.Fl_O2.getPathName(); 
    // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " <- ";
    // tempStr = parent.parent.Fl_I2.getPathName(); 
    // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;


    // cout << parent.getPathName() << " " << "i" << " " << "FsTemp1.Pt" << " " << "FsTemp1.Tt" << " " << "FsTemp2.Pt" << " " << "FsTemp2.Tt" << " " << "dtCheck" << " " << "dtCheck_min" << " " << "pinchLoc" << endl;
    for (i=0;i<nSamp+1;i++) {
      
      FsTemp1.setTotal_hP(Fl_I1.ht-dh1*i/nSamp,Fl_I1.Pt-dP1*i/nSamp);
      FsTemp2.setTotal_hP(Fl_O2.ht-dh2*i/nSamp,Fl_O2.Pt-dP2*i/nSamp);
      
      T1.append(FsTemp1.Tt);
      T2.append(FsTemp2.Tt);
      P1.append(FsTemp1.Pt);
      P2.append(FsTemp2.Pt);

      dtCheck = sgn*(FsTemp1.Tt - FsTemp2.Tt);
      DT.append(dtCheck);
      if (dtCheck < dtCheck_min) {
        dtCheck_min = dtCheck;
        pinchLoc = 1.0*i/nSamp;
      }

      // if (dtCheck * crossLoc > 0) {
      //   // Interpolate to find crossing
      //   // cout << "Cross Detected " << dtCheck << " mode " << crossLoc;
      //   if ( crossLoc < 0 ) {
      //     // Crossed found at Right End
      //     crossLoc = ((minDt - DT[i-1])/(DT[i] - DT[i-1])+(i-1))/nSamp;
      //   } else {
      //     // Crossed already at left end
      //     crossLoc = ((minDt - DT[i-1])/(DT[i] - DT[i-1])+(i-1))/nSamp;
      //   }
      //   // cout << " Location " << crossLoc << endl;
      // }

      // cout << parent.getPathName() << " " << 1.0*i/nSamp << " " << FsTemp1.Pt << " " << FsTemp1.Tt << " " << FsTemp2.Pt << " " << FsTemp2.Tt << " " << dtCheck << " " << dtCheck_min << " " << pinchLoc << endl;
    }

  }

  void adjustQforPinch() {
    // Method, use secant solver to find Q where approach_min == minDt
    // 1. Initial guess for Q
    // 2. Update inlet/outlet for new Q conditions 
    // 3. compute pinchCheck(), set watch for dtCheck_min == minDt

    if ( dtCheck_min < minDt ) {
      cout << "Warning: dtCheck_min < minDt " << dtCheck_min << " < " << minDt << endl;

      real Qbase, Qscaler;
      
      Qscaler = 1.0;
      iterQscaler.initialize(Qscaler);

      Qbase = Q;

      do {

        // Update Q
        Q = Qbase * Qscaler;
        cout << Q << " " << Qbase << " " << Qscaler << " " << dtCheck_min << " " << minDt << endl;

        // string tempStr;
        // cout << "* Before *" << endl;
        // tempStr = parent.parent.Fl_I1.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " -> ";
        // tempStr = parent.parent.Fl_O1.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;
        
        // tempStr = parent.parent.Fl_O2.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " <- ";
        // tempStr = parent.parent.Fl_I2.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;
  

        // Update outlet conditions
        Fl_O1.getParentName()->Fl_O1.setTotal_hP( Fl_I1.ht + Q / Fl_I1.W, Fl_I1.Pt*(1.-dPqP1) );
        Fl_O2.getParentName()->Fl_O2.setTotal_hP( Fl_I2.ht + Q / Fl_I2.W, Fl_I2.Pt*(1.-dPqP2) );
  

        // cout << "* After *" << endl;
        // tempStr = parent.parent.Fl_I1.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " -> ";
        // tempStr = parent.parent.Fl_O1.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;
        
        // tempStr = parent.parent.Fl_O2.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << " <- ";
        // tempStr = parent.parent.Fl_I2.getPathName(); 
        // cout << tempStr << " " << tempStr->Pt << " " << tempStr->Tt << endl;


        // Temp;
        pinchCheck();

        // Qscaler = iterQscaler.iterate( (dtCheck_min - minDt)/minDt );
        Qscaler = iterQscaler.iterate( (dtCheck_min - minDt) );

      } while ( !( iterQscaler.isConverged() ) && !( iterQscaler.errorType ) );
      if (! iterQscaler.isConverged() ) {
        cout << "Warning, " << iterQscaler.getPathName() << " did not converge after " << iterQscaler.numIter << " iterations" << endl;
      }
      if (iterQscaler.errorType ) {
        cout << "Warning, " << iterQscaler.getPathName() << " finished with errorType  " << iterQscaler.errorType << endl;
      }

      // Calculate effectiveness
      calcEffectH();

      cout << "Warning: Duty scaled by " << Qscaler << endl;

    }
    pinchPrint();
  }


  void calculate() {

    //------------------------------------------------------------------
    // Copy entrance conditions to exit
    //------------------------------------------------------------------
    Fl_O1.copyFlow( "Fl_I1" );
    Fl_O2.copyFlow( "Fl_I2" );

    //------------------------------------------------------------------
    // Determine hot and cold streams
    //------------------------------------------------------------------
    if ( Fl_I2.Tt > Fl_I1.Tt ) {
      hotSign = -1.;
      hotSide = "2";
      Fl_Ihot = Fl_I2.getName();
      Fl_Ohot = Fl_O2.getName();
      capHot = cap2.getName();

      coldSide = "1";
      Fl_Icold = Fl_I1.getName();
      Fl_Ocold = Fl_O1.getName();
      capCold = cap1.getName();
    } else {
      hotSign = 1.;
      hotSide = "1";
      Fl_Ihot = Fl_I1.getName();
      Fl_Ohot = Fl_O1.getName();
      capHot = cap1.getName();

      coldSide = "2";
      Fl_Icold = Fl_I2.getName();
      Fl_Ocold = Fl_O2.getName();
      capCold = cap2.getName();
    }

    //------------------------------------------------------------------
    // Calculate the fluid capacity rates (flow x Cp)
    //------------------------------------------------------------------
    cap1 = Fl_I1.W * Fl_I1.Cpt;
    cap2 = Fl_I2.W * Fl_I2.Cpt;
    capMin = min(cap1, cap2);

    //------------------------------------------------------------------
    // Enthalpy based effectiveness
    // Assume 0 R approach temp for max heat capacity
    //------------------------------------------------------------------
    // FlowStation FsTemp;

    // FsTemp.copyFlow("Fl_I1");
    // FsTemp.setTotalTP(Fl_I2.Tt,Fl_I1.Pt);
    // Qmax1 = abs(FsTemp.ht - Fl_I1.ht)*Fl_I1.W;
    Qmax1 = calcApproachQ("Fl_I1",Fl_I2.Tt,dPqP1);

    // Cold Stream
    // FsTemp.copyFlow("Fl_I2");
    // FsTemp.setTotalTP(Fl_I1.Tt,Fl_I2.Pt);
    // Qmax2 = abs(FsTemp.ht - Fl_I2.ht)*Fl_I2.W;
    Qmax2 = calcApproachQ("Fl_I2",Fl_I1.Tt,dPqP2);

    // ("Qmax"+hotSide)->value = calcApproachQ(Fl_Ihot,Fl_Icold->Tt+minDt,("dPqP"+hotSide)->value);
    // ("Qmax"+coldSide)->value = calcApproachQ(Fl_Icold,Fl_Ihot->Tt-minDt,("dPqP"+coldSide)->value);

    // Do not acount for minDt
    ("Qmax"+hotSide)->value = calcApproachQ(Fl_Ihot,Fl_Icold->Tt,("dPqP"+hotSide)->value);
    ("Qmax"+coldSide)->value = calcApproachQ(Fl_Icold,Fl_Ihot->Tt,("dPqP"+coldSide)->value);



    Qmin_h = min(Qmax1, Qmax2);


    //------------------------------------------------------------------
    // Calculate the pressure loss on both sides of the HX
    //------------------------------------------------------------------
    if( !S_dPqP1.isEmpty() ) {
      Fl_dP.copyFlow( "Fl_I1" );
      S_dPqP1.execute();
      dPqP1 = dPqP_dmd;
    }
    if( !S_dPqP2.isEmpty() ) {
      Fl_dP.copyFlow( "Fl_I2" );
      S_dPqP2.execute();
      dPqP2 = dPqP_dmd;
    }


    //------------------------------------------------------------------
    // Calculate the Q or the effectiveness
    //------------------------------------------------------------------
    if ( switchQ == "EFFECT" ) {
      if ( switchEffectCalc == "Cp" ) {
        Q = calcEffectCp(effect_des);
      } else {
        // Q = hotSign*calcEffectH(effect_des);
        Q = hotSign*effect_des*Qmin_h;
      }
    } else if ( switchQ == "Q_des" ){
      Q = Q_des;
    } else if ( switchQ == "APPROACH" ) {
      if ( switchApproachCalc == "cold") {
        Q = hotSign*calcApproachQ(Fl_Ihot,Fl_Icold->Tt+approach_des,("dPqP"+hotSide)->value);
      }
      else if ( switchApproachCalc == "hot") {
        Q = hotSign*calcApproachQ(Fl_Icold,Fl_Ihot->Tt-approach_des,("dPqP"+coldSide)->value);
      }
    } else if ( switchQ == "Q_CALCULATE" ){
      if( !S_Q.isEmpty() ) {
        S_Q.execute();
      }
    } else if ( switchQ == "Q_CUSTOM" ){
      if( !S_customQ.isEmpty() ) {
        S_customQ.execute();
      }
      Q = Q_dmd;
    } else if ( switchQ == "OFF" ){
      Q = 0;
      effect_des = 0;
    }

    //------------------------------------------------------------------
    // Compute outlet streams based on Q
    //------------------------------------------------------------------
    // Check requested Q against available heat capacity
    if ( abs(Q) > Qmin_h ) {
      Q = Qmin_h * Q/abs(Q);
      cout << "WARNING: " << parent.getPathName() << ", Crossover detected, Adjusting to minimum approach temperature (minDt), " << minDt << endl;
    }
    setOutletForQ(Q);

    adjustQforPinch();

    //------------------------------------------------------------------
    // Calculate approach temperatures
    //------------------------------------------------------------------
    approach_cold = Fl_Ohot->Tt - Fl_Icold->Tt;
    approach_hot  = Fl_Ihot->Tt - Fl_Ocold->Tt;
    approach_min = min(approach_cold,approach_hot);

    //------------------------------------------------------------------
    // Calculate the Q
    //------------------------------------------------------------------
    Q = ( Fl_O2.ht - Fl_I2.ht )* Fl_I2.W;

    //------------------------------------------------------------------
    // Calculate Effectiveness
    //------------------------------------------------------------------
    effect_Cp = ( Fl_Ocold->Tt - Fl_Icold->Tt )/( Fl_Ihot->Tt - Fl_Icold->Tt )/( capMin / capCold->value );
    effect_h = abs(Q) / min(Qmax1,Qmax2);

  } // calculate()
} // Element

#endif
